<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silent Horror</title>
    <style>
        /* Basic styling for the body and canvas */
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif; /* Use Inter font */
            background-color: #000; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%; /* Make canvas responsive */
            height: 100%;
            background-color: #000; /* Ensure canvas background is black */
        }

        /* Crosshair Styling */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            display: none; /* Hidden by default, shown when game starts */
        }

        /* Menu Base Styling */
        .game-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: none;
            padding: 40px;
            box-sizing: border-box;
            
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 0;
            text-align: center;
            z-index: 1001;
            border: none;
            box-shadow: none;
            display: flex; /* Always display flex for centering, control visibility with opacity/visibility */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            background: linear-gradient(145deg, rgba(10, 10, 10, 0.95), rgba(30, 30, 30, 0.95));
            border: 2px solid #333;
            box-shadow: 0 0 40px rgba(255, 68, 0, 0.3), 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(3px);

            opacity: 0; /* Hidden by default */
            visibility: hidden; /* Hidden by default */
            pointer-events: none; /* Prevents interaction when hidden */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; /* Smooth transition */
        }

        /* Active Menu Styling */
        .game-menu.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto; /* Allows interaction when active */
        }

        /* Specific Main Menu Styling */
        #main-menu.active {
            /* Main menu is active by default on load */
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .game-menu h2 {
            margin-top: 0;
            font-size: 2.8em;
            color: #ff4400;
            text-shadow: 0 0 15px rgba(255, 68, 0, 0.7), 0 0 5px rgba(255, 68, 0, 0.5);
            letter-spacing: 2px;
            animation: pulse-glow 2s infinite alternate;
        }

        @keyframes pulse-glow {
            from {
                text-shadow: 0 0 15px rgba(255, 68, 0, 0.7), 0 0 5px rgba(255, 68, 0, 0.5);
            }
            to {
                text-shadow: 0 0 25px rgba(255, 68, 0, 0.9), 0 0 10px rgba(255, 68, 0, 0.7);
            }
        }

        .game-menu p {
            margin-bottom: 12px;
            font-size: 1.1em;
            line-height: 1.6;
            color: #ccc;
        }

        .game-menu button {
            background-color: #880000;
            color: #fff;
            border: 1px solid #cc0000;
            padding: 18px 35px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.3em;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            margin-top: 15px;
            letter-spacing: 1px;
            width: 280px; /* Set a fixed width for all buttons */
        }

        .game-menu button:hover {
            background-color: #cc0000;
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 68, 0, 0.5);
        }

        .game-menu button:active {
            transform: translateY(0);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
        }

        /* Slider specific styling */
        .slider-container {
            width: 80%;
            max-width: 400px;
            margin: 20px auto;
            text-align: left;
            color: #eee;
        }

        .slider-container label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .slider-container input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            height: 10px;
            background: #555;
            outline: none;
            border-radius: 5px;
            opacity: 0.8;
            transition: opacity .2s;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #ff4400;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #ff4400;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }


        /* Stamina Bar Styling */
        #stamina-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background-color: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            border: 1px solid #777;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: none; /* Hidden initially, shown when game starts */
        }

        #stamina-bar-fill {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            border-radius: 10px;
            transition: width 0.1s linear;
        }

        /* Score Display Styling */
        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none; /* Hidden initially, shown when game starts */
        }

        /* Game Over Score Styling */
        #game-over-score {
            margin-top: 20px;
            font-size: 1.3em;
            color: #eee;
        }

        #game-over-highscore {
            font-size: 1.3em;
            color: #00ff00; /* Green for high score */
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>

    <div id="main-menu" class="game-menu active">
        <h2>Welcome to Silent Horror</h2>
        <button id="start-game-button">Start Game</button>
        <button id="mechanics-button">Mechanics</button>
        <button id="options-button">Options</button>
        <button id="quit-game-main-menu">Quit Game</button>
    </div>

    <div id="mechanics-menu" class="game-menu">
        <h2>Game Mechanics</h2>
        <p>Use W, A, S, D to move. Look around with your mouse.</p>
        <p>Press SPACE to Jump and C to Crouch.</p>
        <p>Press SHIFT to Sprint (consumes stamina). You can sprint as long as you have stamina.</p>
        <p>Press ESC to Pause the game.</p>
        <button id="back-to-main-menu-button">Back to Main Menu</button>
    </div>

    <div id="options-menu" class="game-menu">
        <h2>Options</h2>
        <div class="slider-container">
            <label for="render-distance-slider">Render Distance:</label>
            <input type="range" id="render-distance-slider" min="1" max="10" value="5">
            <span id="render-distance-value">500 meters</span>
        </div>
        <div class="slider-container">
            <label for="music-volume-slider">Music Volume:</label>
            <input type="range" id="music-volume-slider" min="1" max="10" value="5">
            <span id="music-volume-value">5</span>
        </div>
        <button id="back-button-from-options">Back</button> 
    </div>

    <div id="pause-menu" class="game-menu">
        <h2>Game Paused</h2>
        <button id="resume-button">Resume Game</button>
        <button id="options-button-pause-menu">Options</button>
        <button id="quit-button-pause-menu">Quit Game</button>
    </div>

    <div id="game-over-menu" class="game-menu">
        <h2>Game Over!</h2>
        <p>The ghost caught you.</p>
        <p id="game-over-score">Score: 0</p>
        <p id="game-over-highscore">High Score: 0</p>
        <button id="restart-game-button-gameover">Restart Game</button>
        <button id="main-menu-button-gameover">Main Menu</button>
    </div>

    <div id="stamina-bar-container">
        <div id="stamina-bar-fill"></div>
    </div>

    <div id="score-display">Score: 0</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables for Three.js components
        let scene, camera, renderer;
        let player; // A group to hold the camera for better movement control
        let playerVelocity = new THREE.Vector3();
        let playerVerticalVelocity = 0; // For jumping/gravity
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isJumping = false;
        let isCrouching = false;
        let prevTime = performance.now(); // Stores the time of the previous frame
        let crosshair;
        let ghost; // The ghost object
        let obstacles = []; // Array to store objects for collision detection

        // Game state variables
        let isPaused = true; // Game starts paused to show the main menu
        let gameStarted = false; // Flag to track if the game has started
        let animationFrameId; // To store the ID of the requestAnimationFrame
        let lastMenuOpened = 'main-menu'; // Tracks which menu opened the options, for back button logic

        // Stamina variables
        const MAX_STAMINA = 100;
        const STAMINA_DRAIN_DURATION = 5; // seconds to drain fully
        const STAMINA_REGEN_DURATION = 8; // seconds to replenish fully
        let playerStamina = MAX_STAMINA;
        let staminaDrainRate = MAX_STAMINA / STAMINA_DRAIN_DURATION;
        let staminaRegenRate = MAX_STAMINA / STAMINA_REGEN_DURATION;
        let isSprintKeyDown = false; // Tracks if the Shift key is currently held down
        let isCurrentlySprinting = false; // Tracks if the player is actually moving at sprint speed
        let staminaBarFill; // Reference to the stamina bar fill element

        // Scoring variables
        let score = 0;
        let highScore = localStorage.getItem('silentHorrorHighScore') ? parseInt(localStorage.getItem('silentHorrorHighScore')) : 0;
        const SCORE_PER_SECOND = 10;
        let scoreDisplay; // Reference to the score display element
        let gameOverScoreDisplay; // Reference to the game over score display
        let gameOverHighScoreDisplay; // Reference to the game over high score display

        // Constants for game environment and speeds
        const FOREST_SIZE = 500; // Increased size for a much larger forest
        const STAND_HEIGHT = 5; // Original player height
        const CROUCH_HEIGHT = 2.5; // Player height when crouching
        let PLAYER_HEIGHT = STAND_HEIGHT; // Current player height (changes with crouching)
        const NORMAL_PLAYER_SPEED = 15; // Normal walking speed
        const SPRINT_SPEED_VALUE = 25; // Target speed when sprinting
        const CROUCH_SPEED_MULTIPLIER = 0.5; // Player speed when crouching (relative to current speed)
        const LOOK_SPEED = 0.002; // Mouse look sensitivity
        const PLAYER_COLLISION_RADIUS = 0.5; // Player collision radius (adjusted to 0.5)
        const GHOST_COLLISION_RADIUS = 2; // Approximate collision radius for the ghost model
        const JUMP_FORCE = 15; // Initial upward velocity for jump
        const GRAVITY = 40; // Gravity strength

        let GHOST_SPEED; // Will be set in init()
        let OUT_OF_STAMINA_PLAYER_SPEED; // Will be set in init()

        // Render distance variables
        let renderDistanceSetting = 5; // Default to 5 (500 meters)
        let actualRenderDistance; // Calculated based on setting

        // Audio variables (using Tone.js)
        let backgroundMusicOscillator; // Changed from loop to direct oscillator
        let buttonClickSynth;
        let musicVolumeSlider;
        let musicVolumeValueDisplay;


        // Helper function to toggle menu visibility
        function toggleMenu(menuElement, show) {
            if (show) {
                menuElement.classList.add('active');
            } else {
                menuElement.classList.remove('active');
            }
        }

        // Initialize the game
        async function init() { // Made async to await Tone.start()
            try {
                // Calculate dynamic speeds
                GHOST_SPEED = NORMAL_PLAYER_SPEED * 1.40; // Ghost speed is 1.40x of NORMAL_PLAYER_SPEED when player is not sprinting
                OUT_OF_STAMINA_PLAYER_SPEED = GHOST_SPEED * 0.70; // Player speed when out of stamina is 0.70x ghost speed

                // Get DOM elements
                crosshair = document.getElementById('crosshair');
                const mainMenu = document.getElementById('main-menu');
                const pauseMenu = document.getElementById('pause-menu');
                const gameOverMenu = document.getElementById('game-over-menu');
                const mechanicsMenu = document.getElementById('mechanics-menu');
                const optionsMenu = document.getElementById('options-menu'); // New
                const startGameButton = document.getElementById('start-game-button');
                const resumeButton = document.getElementById('resume-button');
                const mainMenuButtonGameOver = document.getElementById('main-menu-button-gameover');
                const restartGameButtonGameOver = document.getElementById('restart-game-button-gameover');
                const mechanicsButton = document.getElementById('mechanics-button');
                const optionsButton = document.getElementById('options-button'); // Main menu options button
                const optionsButtonPauseMenu = document.getElementById('options-button-pause-menu'); // Pause menu options button
                const backToMainMenuButton = document.getElementById('back-to-main-menu-button');
                const backButtonFromOptions = document.getElementById('back-button-from-options'); // Unified back button in options
                const quitGameMainMenuButton = document.getElementById('quit-game-main-menu');
                const quitGamePauseMenuButton = document.getElementById('quit-button-pause-menu');
                staminaBarFill = document.getElementById('stamina-bar-fill');
                scoreDisplay = document.getElementById('score-display'); // Get score display element
                gameOverScoreDisplay = document.getElementById('game-over-score'); // Get game over score display
                gameOverHighScoreDisplay = document.getElementById('game-over-highscore'); // Get game over high score display

                // Render distance slider elements
                renderDistanceSlider = document.getElementById('render-distance-slider');
                renderDistanceValueDisplay = document.getElementById('render-distance-value');

                // Audio setup using Tone.js Synths for internal sound generation
                // Button click sound
                buttonClickSynth = new Tone.Synth().toDestination();
                buttonClickSynth.volume.value = -10; // Adjust volume for click sound

                // Background music oscillator (for a continuous drone)
                backgroundMusicOscillator = new Tone.Oscillator({
                    frequency: 50, // Low frequency for drone
                    type: "sine", // Smooth sine wave
                    volume: -20 // Start quiet, volume controlled by slider
                }).toDestination();

                musicVolumeSlider = document.getElementById('music-volume-slider');
                musicVolumeValueDisplay = document.getElementById('music-volume-value');

                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000); // Black background

                // Camera setup (PerspectiveCamera for 3D view)
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 0); // Camera is now at (0,0,0) relative to its parent (player)

                // Player group setup
                player = new THREE.Object3D();
                // Randomize player spawn position within forest boundaries
                player.position.set(
                    (Math.random() - 0.5) * FOREST_SIZE * 1.8, // Random X within forest bounds
                    PLAYER_HEIGHT,
                    (Math.random() - 0.5) * FOREST_SIZE * 1.8  // Random Z within forest bounds
                );
                player.add(camera); // Add camera as a child of the player group
                scene.add(player);

                // Renderer setup (WebGLRenderer)
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);

                // Add a more visible ambient light to slightly illuminate the scene
                const ambientLight = new THREE.AmbientLight(0x777777); // Slightly darker ambient light
                scene.add(ambientLight);

                // Create a flickering point light to add horror atmosphere
                const flickeringLight = new THREE.PointLight(0xff4400, 2, 25); // Slightly brighter, more orange-red light, increased distance
                flickeringLight.position.set(0, 10, 0); // Position it in the center of the forest
                scene.add(flickeringLight);

                // Store the initial intensity for flickering
                flickeringLight.userData.initialIntensity = flickeringLight.intensity;
                flickeringLight.userData.flickerSpeed = 0.15; // How fast it flickers, slightly faster
                flickeringLight.userData.flickerAmount = 0.7; // How much it flickers, more pronounced
                flickeringLight.userData.minIntensity = 0.5; // Minimum intensity during flicker

                // Create the forest environment
                createForest();

                // Add the ghost
                addGhost();

                // Event Listeners for player controls
                setupControls();

                // Handle window resizing
                window.addEventListener('resize', onWindowResize, false);

                // Set initial render distance
                renderDistanceSlider.value = renderDistanceSetting;
                updateRenderDistance(); // Call to set initial actualRenderDistance and camera.far

                // Set initial music volume from local storage or default
                const savedVolume = localStorage.getItem('musicVolume');
                let initialVolume = savedVolume ? parseFloat(savedVolume) : 5; // Default to 5 if not saved
                musicVolumeSlider.value = initialVolume;
                // Map 1-10 slider value to a decibel range for Tone.js volume
                // A range from -40dB (very quiet) to 0dB (full volume) seems appropriate for a 1-10 slider
                Tone.Destination.volume.value = (initialVolume - 1) * 40 / 9 - 40; // Linear map from 1-10 to -40dB to 0dB
                musicVolumeValueDisplay.textContent = initialVolume;

                // Function to start audio context on first user interaction
                const startAudioContext = async () => {
                    console.log('startAudioContext triggered. Tone.context.state:', Tone.context.state);
                    if (Tone.context.state !== 'running') {
                        try {
                            await Tone.start();
                            console.log('AudioContext successfully started by Tone.start().');
                        } catch (e) {
                            console.error('Failed to start AudioContext:', e);
                            return; // Exit if context failed to start
                        }
                    } else {
                        console.log('AudioContext already running.');
                    }

                    // After ensuring context is running, if game is paused (on a menu)
                    // and music isn't already playing, start it.
                    if (isPaused && backgroundMusicOscillator.state !== 'started') {
                        backgroundMusicOscillator.start();
                        console.log('Background music started from startAudioContext (game is paused/on menu).');
                    } else if (!isPaused) {
                        console.log('Background music not started from startAudioContext because game is not paused.');
                    } else if (backgroundMusicOscillator.state === 'started') {
                        console.log('Background music not started from startAudioContext: Already playing.');
                    }

                    // Remove listeners only after context is running and music is attempted to be started
                    document.removeEventListener('click', startAudioContext);
                    document.removeEventListener('keydown', startAudioContext);
                };

                // Attach event listeners to start audio context
                document.addEventListener('click', startAudioContext);
                document.addEventListener('keydown', startAudioContext);

                // Main Menu "Start Game" button functionality
                startGameButton.addEventListener('click', async () => {
                    console.log('Start Game button clicked.');
                    await Tone.start(); // Ensure audio context is running (redundant but safe after startAudioContext)
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    gameStarted = true;
                    isPaused = false; // Unpause the game
                    toggleMenu(mainMenu, false); // Hide main menu
                    document.getElementById('stamina-bar-container').style.display = 'block'; // Show stamina bar
                    scoreDisplay.style.display = 'block'; // Show score display
                    renderer.domElement.requestPointerLock(); // Request pointer lock
                    prevTime = performance.now(); // Reset prevTime when starting game
                    if (backgroundMusicOscillator.state === 'started') {
                        backgroundMusicOscillator.stop(); // Stop background music when game starts
                        console.log('Background music stopped by Start Game button.');
                    } else {
                        console.log('Background music was not started when Start Game button clicked.');
                    }
                    animate(); // Start the animation loop
                });

                // Mechanics button functionality
                mechanicsButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    toggleMenu(mainMenu, false);
                    toggleMenu(mechanicsMenu, true);
                });

                // Options button functionality (from main menu)
                optionsButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    lastMenuOpened = 'main-menu'; // Set origin for back button
                    toggleMenu(mainMenu, false);
                    toggleMenu(optionsMenu, true);
                });

                // Options button functionality (from pause menu)
                optionsButtonPauseMenu.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    lastMenuOpened = 'pause-menu'; // Set origin for back button
                    toggleMenu(pauseMenu, false);
                    toggleMenu(optionsMenu, true);
                });

                // Back to Main Menu button in Mechanics functionality
                backToMainMenuButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    toggleMenu(mechanicsMenu, false);
                    toggleMenu(mainMenu, true);
                });

                // Unified Back button in Options functionality
                backButtonFromOptions.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    toggleMenu(optionsMenu, false);
                    if (lastMenuOpened === 'main-menu') {
                        toggleMenu(mainMenu, true);
                    } else if (lastMenuOpened === 'pause-menu') {
                        toggleMenu(pauseMenu, true);
                    }
                });

                // Render distance slider event listener
                renderDistanceSlider.addEventListener('input', updateRenderDistance);

                // Music volume slider event listener
                musicVolumeSlider.addEventListener('input', () => {
                    const volume = parseFloat(musicVolumeSlider.value);
                    // Map 1-10 to dB range (-40dB to 0dB) for the master volume
                    Tone.Destination.volume.value = (volume - 1) * 40 / 9 - 40; 
                    musicVolumeValueDisplay.textContent = volume;
                    localStorage.setItem('musicVolume', volume); // Save volume to local storage
                });

                // Pause Menu "Resume Game" button functionality
                resumeButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    togglePause(); // This will unpause the game
                });

                // Quit Game buttons
                quitGameMainMenuButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    window.location.reload(); // Reload the page to "quit" from main menu
                });
                quitGamePauseMenuButton.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    window.location.reload(); // Reload the page to "quit" from pause menu
                });

                // Game Over "Main Menu" button functionality
                mainMenuButtonGameOver.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    resetGameAndShowMainMenu(); // Call function to reset and show main menu
                });

                // Game Over "Restart Game" button functionality
                restartGameButtonGameOver.addEventListener('click', async () => {
                    await Tone.start(); // Ensure audio context is running
                    buttonClickSynth.triggerAttackRelease("C4", "8n"); // Play a click sound
                    resetGameAndStart(); // Call new function to reset and immediately start the game
                });

                // Initial render (main menu is visible by default)
                renderer.render(scene, camera);
                // The animate loop is started inside init, but isPaused is true, so it will render only.
                // It will fully start updating game logic when the "Start Game" button is clicked.
            } catch (error) {
                console.error("Error during initialization:", error);
                // Display error message to user on the main menu
                const mainMenu = document.getElementById('main-menu');
                if (mainMenu) {
                    mainMenu.innerHTML = `<h2>Error!</h2><p>An error occurred: ${error.message}</p><p>Please try refreshing the page.</p>`;
                    mainMenu.classList.add('active'); // Ensure error message is visible
                }
            }
        }

        // Function to create the forest environment
        function createForest() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(FOREST_SIZE * 2, FOREST_SIZE * 2); // Larger ground
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x335533, // Slightly darker green for forest floor
                shininess: 0,
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be flat
            ground.position.y = 0;
            scene.add(ground);

            // Trees
            const numTrees = 800; // Number of trees
            for (let i = 0; i < numTrees; i++) {
                const treeGroup = new THREE.Group();

                // Trunk
                const trunkHeight = Math.random() * 5 + 8; // Random height between 8 and 13
                const trunkRadius = Math.random() * 0.3 + 0.5; // Random radius between 0.5 and 0.8
                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius * 1.2, trunkHeight, 6);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x664422, shininess: 0 }); // Slightly darker brown
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2; // Position trunk correctly relative to its group

                // Foliage (cone shape)
                const foliageHeight = Math.random() * 4 + 6; // Random height between 6 and 10
                const foliageRadius = Math.random() * 2 + 3; // Random radius between 3 and 5
                const foliageGeometry = new THREE.ConeGeometry(foliageRadius, foliageHeight, 8);
                const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x224422, shininess: 0 }); // Slightly darker green
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + foliageHeight / 2 - 1; // Position foliage above trunk

                treeGroup.add(trunk);
                treeGroup.add(foliage);

                // Random position within forest bounds
                treeGroup.position.x = (Math.random() - 0.5) * FOREST_SIZE * 1.8;
                treeGroup.position.z = (Math.random() - 0.5) * FOREST_SIZE * 1.8;
                scene.add(treeGroup);

                // For collision, we want only the trunk's bounding box
                // We need the trunk's world position for its bounding box
                trunk.updateMatrixWorld(true); // Ensure world matrix is updated
                const trunkBbox = new THREE.Box3().setFromObject(trunk);
                obstacles.push({ object: treeGroup, bbox: trunkBbox, type: 'tree' }); // Store treeGroup for removal, but use trunkBbox for collision
            }

            // Small Rocks
            const numSmallRocks = 350; // Number of small rocks
            for (let i = 0; i < numSmallRocks; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 1.5 + 1); // Irregular polyhedra for rocks
                const rockMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, shininess: 0 }); // Slightly darker grey
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);

                rock.position.x = (Math.random() - 0.5) * FOREST_SIZE * 1.8;
                rock.position.z = (Math.random() - 0.5) * FOREST_SIZE * 1.8;
                rock.position.y = rock.geometry.parameters.radius * rock.scale.y / 2; // Place on ground
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // Random rotation

                scene.add(rock);
                rock.updateMatrixWorld(true); // Ensure world matrix is updated
                // Use a bounding sphere for rocks for more accurate collision
                // Manually create the sphere and set its center and radius
                const rockBoundingSphere = new THREE.Sphere(rock.position.clone(), rock.geometry.parameters.radius * 0.9); // Increased radius multiplier
                obstacles.push({ object: rock, bbox: rockBoundingSphere, type: 'rock' });
            }

            // Bigger Rocks (like mountains)
            const numLargeRocks = 50; // Number of large rocks
            for (let i = 0; i < numLargeRocks; i++) {
                const largeRockGeometry = new THREE.IcosahedronGeometry(Math.random() * 4 + 6); // Smaller range for large rocks
                const largeRockMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 0 }); // Slightly darker grey
                const largeRock = new THREE.Mesh(largeRockGeometry, largeRockMaterial);

                largeRock.position.x = (Math.random() - 0.5) * FOREST_SIZE * 1.5; // Slightly less spread
                largeRock.position.z = (Math.random() - 0.5) * FOREST_SIZE * 1.5;
                largeRock.position.y = largeRock.geometry.parameters.radius / 2; // Place on ground
                largeRock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                scene.add(largeRock);
                largeRock.updateMatrixWorld(true); // Ensure world matrix is updated
                // Use a bounding sphere for large rocks for more accurate collision
                // Manually create the sphere and set its center and radius
                const largeRockBoundingSphere = new THREE.Sphere(largeRock.position.clone(), largeRock.geometry.parameters.radius * 0.9); // Increased radius multiplier
                obstacles.push({ object: largeRock, bbox: largeRockBoundingSphere, type: 'rock' });
            }

            // Add visible map boundaries (walls)
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x2a2a2a, side: THREE.DoubleSide, shininess: 0 }); // Slightly darker dark grey
            const wallHeight = FOREST_SIZE / 2; // Half the forest size for height
            const wallThickness = 2; // Thickness of the walls

            // North Wall
            const northWall = new THREE.Mesh(new THREE.BoxGeometry(FOREST_SIZE * 2 + wallThickness * 2, wallHeight, wallThickness), wallMaterial);
            northWall.position.set(0, wallHeight / 2, -FOREST_SIZE);
            scene.add(northWall);
            obstacles.push({ object: northWall, bbox: new THREE.Box3().setFromObject(northWall), type: 'boundary' });

            // South Wall
            const southWall = new THREE.Mesh(new THREE.BoxGeometry(FOREST_SIZE * 2 + wallThickness * 2, wallHeight, wallThickness), wallMaterial);
            southWall.position.set(0, wallHeight / 2, FOREST_SIZE);
            scene.add(southWall);
            obstacles.push({ object: southWall, bbox: new THREE.Box3().setFromObject(southWall), type: 'boundary' });

            // East Wall
            const eastWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, FOREST_SIZE * 2 + wallThickness * 2), wallMaterial);
            eastWall.position.set(FOREST_SIZE, wallHeight / 2, 0);
            scene.add(eastWall);
            obstacles.push({ object: eastWall, bbox: new THREE.Box3().setFromObject(eastWall), type: 'boundary' });

            // West Wall
            const westWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, FOREST_SIZE * 2 + wallThickness * 2), wallMaterial);
            westWall.position.set(-FOREST_SIZE, wallHeight / 2, 0);
            scene.add(westWall);
            obstacles.push({ object: westWall, bbox: new THREE.Box3().setFromObject(westWall), type: 'boundary' });
        }

        // Function to add the geometric ghost model
        function addGhost() {
            if (ghost) { // Remove existing ghost if any
                scene.remove(ghost);
                ghost = null; // Clear reference
            }

            ghost = new THREE.Group();

            // Body (cone)
            const ghostBodyGeometry = new THREE.ConeGeometry(2, 4, 8); // Radius, height, radial segments
            const ghostBodyMaterial = new THREE.MeshBasicMaterial({
                color: 0xeeeeee, // Off-white/light grey
                transparent: true,
                opacity: 0.4, // Semi-transparent
                side: THREE.DoubleSide // Render both sides
            });
            const ghostBody = new THREE.Mesh(ghostBodyGeometry, ghostBodyMaterial);
            ghostBody.position.y = 2; // Position so its base is at y=0 relative to the group

            // Head (sphere)
            const ghostHeadGeometry = new THREE.SphereGeometry(1.5, 16, 16); // Radius, width segments, height segments
            const ghostHeadMaterial = new THREE.MeshBasicMaterial({
                color: 0xeeeeee,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const ghostHead = new THREE.Mesh(ghostHeadGeometry, ghostHeadMaterial);
            ghostHead.position.y = 4 + 1.5; // Position above the cone body

            ghost.add(ghostBody);
            ghost.add(ghostHead);

            // Calculate ghost model's total height for positioning
            const ghostModelHeight = 4 + 1.5; // Cone height + sphere radius
            // Position the ghost group such that its base is roughly at y=0 (ground level)
            ghost.position.y = ghostModelHeight / 2; // Center the ghost's entire model at this height

            const spawnDistance = 100; // Fixed distance from player for ghost spawn
            let ghostSpawnX, ghostSpawnZ;

            // Loop until a suitable spawn position is found
            while (true) {
                const angle = Math.random() * Math.PI * 2;
                ghostSpawnX = player.position.x + Math.cos(angle) * spawnDistance;
                ghostSpawnZ = player.position.z + Math.sin(angle) * spawnDistance;

                const tempSpawnPosition = new THREE.Vector3(ghostSpawnX, ghost.position.y, ghostSpawnZ); // Use ghost's adjusted Y

                const isInBounds = (
                    tempSpawnPosition.x > -FOREST_SIZE + GHOST_COLLISION_RADIUS &&
                    tempSpawnPosition.x < FOREST_SIZE - GHOST_COLLISION_RADIUS &&
                    tempSpawnPosition.z > -FOREST_SIZE + GHOST_COLLISION_RADIUS &&
                    tempSpawnPosition.z < FOREST_SIZE - GHOST_COLLISION_RADIUS
                );

                if (isInBounds) {
                    ghost.position.x = tempSpawnPosition.x;
                    ghost.position.z = tempSpawnPosition.z;
                    break;
                }
            }
            scene.add(ghost);
        }


        // Function to toggle pause state
        function togglePause() {
            const mainMenu = document.getElementById('main-menu');
            const pauseMenu = document.getElementById('pause-menu');
            const staminaBarContainer = document.getElementById('stamina-bar-container');
            const gameOverMenu = document.getElementById('game-over-menu');
            const mechanicsMenu = document.getElementById('mechanics-menu');
            const optionsMenu = document.getElementById('options-menu');
            const scoreDisplay = document.getElementById('score-display');


            if (isPaused) { // If currently paused (or at initial start screen)
                console.log("Unpausing game. isPaused was true, now false.");
                // Unpause the game
                isPaused = false;
                toggleMenu(mainMenu, false); // Hide main menu
                toggleMenu(pauseMenu, false); // Hide pause menu
                toggleMenu(gameOverMenu, false); // Ensure game over menu is hidden
                toggleMenu(mechanicsMenu, false); // Ensure mechanics menu is hidden
                toggleMenu(optionsMenu, false); // Ensure options menu is hidden
                document.getElementById('stamina-bar-container').style.display = 'block'; // Show stamina bar
                scoreDisplay.style.display = 'block'; // Show score display
                renderer.domElement.requestPointerLock(); // Request pointer lock
                prevTime = performance.now(); // Reset prevTime to current time when unpausing to ensure smooth delta calculation
                if (backgroundMusicOscillator.state === 'started') { // Check if it's already playing before stopping
                    backgroundMusicOscillator.stop(); // Stop background music when game resumes
                    console.log('Background music stopped by Unpause.');
                }
                animate(); // Restart the animation loop
            } else { // If currently playing
                console.log("Pausing game. isPaused was false, now true.");
                // Pause the game
                isPaused = true;
                cancelAnimationFrame(animationFrameId); // Stop the animation loop
                document.exitPointerLock(); // Release pointer lock
                crosshair.style.display = 'none'; // Hide crosshair
                staminaBarContainer.style.display = 'none'; // Hide stamina bar when paused
                scoreDisplay.style.display = 'none'; // Hide score display when paused
                // Start background music when paused and on a menu
                if (Tone.context.state === 'running' && backgroundMusicOscillator.state !== 'started' && (pauseMenu.classList.contains('active') || mainMenu.classList.contains('active') || gameOverMenu.classList.contains('active') || mechanicsMenu.classList.contains('active') || optionsMenu.classList.contains('active'))) {
                    backgroundMusicOscillator.start();
                    console.log('Background music started by Pause (on menu).');
                } else if (Tone.context.state !== 'running') {
                    console.log('Background music not started by Pause: AudioContext not running.');
                } else if (backgroundMusicOscillator.state === 'started') {
                    console.log('Background music not started by Pause: Already playing.');
                }
            }
        }

        // Function to handle game over
        function gameOver() {
            isPaused = true; // Effectively pause the game
            cancelAnimationFrame(animationFrameId); // Stop the animation loop
            document.exitPointerLock(); // Release pointer lock
            crosshair.style.display = 'none'; // Hide crosshair
            document.getElementById('stamina-bar-container').style.display = 'none'; // Hide stamina bar
            scoreDisplay.style.display = 'none'; // Hide score display
            if (Tone.context.state === 'running' && backgroundMusicOscillator.state !== 'started') {
                backgroundMusicOscillator.start(); // Play background music on game over
                console.log('Background music started by Game Over.');
            } else if (Tone.context.state !== 'running') {
                console.log('Background music not started by Game Over: AudioContext not running.');
            } else if (backgroundMusicOscillator.state === 'started') {
                console.log('Background music not started by Game Over: Already playing.');
            }

            // Update high score
            if (score > highScore) {
                highScore = Math.floor(score); // Ensure high score is also an integer
                localStorage.setItem('silentHorrorHighScore', highScore);
            }

            // Display scores on game over menu
            gameOverScoreDisplay.textContent = `Score: ${Math.floor(score)}`; // Display integer score
            gameOverHighScoreDisplay.textContent = `High Score: ${highScore}`;

            toggleMenu(document.getElementById('main-menu'), false); // Ensure main menu is hidden
            toggleMenu(document.getElementById('pause-menu'), false); // Ensure pause menu is hidden
            toggleMenu(document.getElementById('mechanics-menu'), false); // Ensure mechanics menu is hidden
            toggleMenu(document.getElementById('options-menu'), false); // Ensure options menu is hidden
            toggleMenu(document.getElementById('game-over-menu'), true); // Show game over menu
        }

        // Function to reset game state and show main menu
        function resetGameAndShowMainMenu() {
            // Reset game state variables
            isPaused = true;
            gameStarted = false;
            playerStamina = MAX_STAMINA;
            staminaDrainRate = MAX_STAMINA / STAMINA_DRAIN_DURATION;
            staminaRegenRate = MAX_STAMINA / STAMINA_REGEN_DURATION;
            isSprintKeyDown = false;
            isCurrentlySprinting = false;
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            isJumping = false;
            isCrouching = false;
            playerVerticalVelocity = 0;
            PLAYER_HEIGHT = STAND_HEIGHT;
            score = 0; // Reset score
            prevTime = performance.now(); // Reset time for animation loop

            // Stop any ongoing animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Reset player position (randomize again for a fresh start)
            player.position.set(
                (Math.random() - 0.5) * FOREST_SIZE * 1.8,
                PLAYER_HEIGHT,
                (Math.random() - 0.5) * FOREST_SIZE * 1.8
            );
            player.rotation.set(0, 0, 0); // Reset player rotation
            camera.rotation.set(0, 0, 0); // Reset camera pitch

            // Re-add ghost (will spawn at new random 100m location)
            addGhost();

            // Update UI visibility
            toggleMenu(document.getElementById('main-menu'), true);
            toggleMenu(document.getElementById('pause-menu'), false);
            toggleMenu(document.getElementById('game-over-menu'), false);
            toggleMenu(document.getElementById('mechanics-menu'), false); // Hide mechanics menu
            toggleMenu(document.getElementById('options-menu'), false); // Hide options menu
            document.getElementById('stamina-bar-container').style.display = 'none';
            scoreDisplay.style.display = 'none'; // Hide score display
            crosshair.style.display = 'none';

            // Ensure pointer lock is exited
            document.exitPointerLock();

            // Play background music when returning to main menu
            if (Tone.context.state === 'running' && backgroundMusicOscillator.state !== 'started') {
                backgroundMusicOscillator.start();
                console.log('Background music started by resetGameAndShowMainMenu.');
            } else if (Tone.context.state !== 'running') {
                console.log('Background music not started by resetGameAndShowMainMenu: AudioContext not running.');
            } else if (backgroundMusicOscillator.state === 'started') {
                console.log('Background music not started by resetGameAndShowMainMenu: Already playing.');
            }

            // Re-render the scene to show the main menu
            renderer.render(scene, camera);
            updateRenderDistance(); // Re-evaluate object visibility after reset
        }

        // Function to reset game state and immediately start the game
        function resetGameAndStart() {
            // Reset game state variables
            isPaused = false; // Game will start immediately
            gameStarted = true; // Game is now started
            playerStamina = MAX_STAMINA;
            staminaDrainRate = MAX_STAMINA / STAMINA_DRAIN_DURATION; 
            staminaRegenRate = MAX_STAMINA / STAMINA_REGEN_DURATION;
            isSprintKeyDown = false;
            isCurrentlySprinting = false;
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            isJumping = false;
            isCrouching = false;
            playerVerticalVelocity = 0;
            PLAYER_HEIGHT = STAND_HEIGHT;
            score = 0; // Reset score
            prevTime = performance.now(); // Reset time for animation loop

            // Stop any ongoing animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Reset player position (randomize again for a fresh start)
            player.position.set(
                (Math.random() - 0.5) * FOREST_SIZE * 1.8,
                PLAYER_HEIGHT,
                (Math.random() - 0.5) * FOREST_SIZE * 1.8
            );
            player.rotation.set(0, 0, 0); // Reset player rotation
            camera.rotation.set(0, 0, 0); // Reset camera pitch

            // Re-add ghost (will spawn at new random 100m location)
            addGhost();

            // Update UI visibility
            toggleMenu(document.getElementById('main-menu'), false);
            toggleMenu(document.getElementById('pause-menu'), false);
            toggleMenu(document.getElementById('game-over-menu'), false);
            toggleMenu(document.getElementById('mechanics-menu'), false);
            toggleMenu(document.getElementById('options-menu'), false);
            document.getElementById('stamina-bar-container').style.display = 'block';
            scoreDisplay.style.display = 'block'; // Show score display
            crosshair.style.display = 'block'; // Show crosshair immediately

            // Request pointer lock
            renderer.domElement.requestPointerLock();
            if (backgroundMusicOscillator.state === 'started') { // Check if it's already playing before stopping
                backgroundMusicOscillator.stop(); // Stop background music when game starts
                console.log('Background music stopped by resetGameAndStart.');
            } else {
                console.log('Background music was not started when resetGameAndStart clicked.');
            }

            // Start the animation loop
            animate();
            updateRenderDistance(); // Re-evaluate object visibility after reset
        }


        // Setup mouse and keyboard controls
        function setupControls() {
            // Mouse look (pointer lock)
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('pointerlockchange', onPointerLockChange, false);
            document.addEventListener('error', (e) => console.error("DOM Error:", e), true); // Catch general DOM errors

            // Keyboard movement
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            // Add event listener for 'Esc' key to toggle pause
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Escape' && gameStarted) { // Only toggle pause menu if game has started
                    togglePause();
                }
            }, false);
        }

        // Handle pointer lock change
        function onPointerLockChange() {
            const mainMenu = document.getElementById('main-menu');
            const pauseMenu = document.getElementById('pause-menu');
            const gameOverMenu = document.getElementById('game-over-menu');
            const mechanicsMenu = document.getElementById('mechanics-menu');
            const optionsMenu = document.getElementById('options-menu');
            const scoreDisplay = document.getElementById('score-display');

            if (document.pointerLockElement === renderer.domElement) {
                console.log('Pointer locked');
                // When pointer is locked, show crosshair
                crosshair.style.display = 'block';
                // Ensure menus and score are hidden if game is not paused
                if (!isPaused) {
                    toggleMenu(mainMenu, false);
                    toggleMenu(pauseMenu, false);
                    toggleMenu(gameOverMenu, false);
                    toggleMenu(mechanicsMenu, false);
                    toggleMenu(optionsMenu, false);
                    scoreDisplay.style.display = 'block';
                }
            } else {
                console.log('Pointer unlocked');
                crosshair.style.display = 'none'; // Hide crosshair when unlocked
                // If pointer lock is lost and not explicitly paused, it means the user clicked outside
                // or some other browser event caused it. In this case, we should pause the game.
                if (gameStarted && !isPaused) { // Only auto-pause if game has started and isn't already paused
                    togglePause(); // Automatically pause if pointer lock is lost unexpectedly
                }
            }
        }

        // Handle mouse movement for camera rotation
        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement && !isPaused) { // Only move camera if not paused
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                // Rotate player horizontally (yaw)
                player.rotation.y -= movementX * LOOK_SPEED;

                // Rotate camera vertically (pitch)
                // Limit vertical rotation to prevent flipping
                let newPitch = camera.rotation.x - movementY * LOOK_SPEED;
                newPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newPitch)); // Limit to -90 to +90 degrees
                camera.rotation.x = newPitch;
            }
        }

        // Handle keyboard key down
        function onKeyDown(event) {
            if (isPaused) return; // Do not process movement keys if paused

            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (!isJumping) {
                        playerVerticalVelocity = JUMP_FORCE;
                        isJumping = true;
                    }
                    break;
                case 'KeyC':
                    if (!isCrouching) {
                        isCrouching = true;
                        PLAYER_HEIGHT = CROUCH_HEIGHT;
                        player.position.y = PLAYER_HEIGHT;
                    } else {
                        // Attempt to stand up - check if space above is clear (simplified)
                        // For a more robust check, you'd raycast upwards.
                        // For now, we'll assume it's always possible to stand up if not jumping.
                        if (!isJumping) {
                            isCrouching = false;
                            PLAYER_HEIGHT = STAND_HEIGHT;
                            player.position.y = PLAYER_HEIGHT;
                        }
                    }
                    break;
                case 'ShiftLeft': // Sprint key
                case 'ShiftRight':
                    isSprintKeyDown = true; // Simply track if the key is down
                    break;
            }
        }

        // Handle keyboard key up
        function onKeyUp(event) {
            if (isPaused) return; // Do not process movement keys if paused

            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft': // Sprint key
                case 'ShiftRight':
                    isSprintKeyDown = false; // Key is no longer down
                    break;
            }
        }

        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Function to check for collisions
        function checkCollisions(potentialPosition) {
            // Create a bounding sphere for the player at the potential new position
            const playerBoundingSphere = new THREE.Sphere(potentialPosition, PLAYER_COLLISION_RADIUS);

            for (let i = 0; i < obstacles.length; i++) {
                const obstacleData = obstacles[i];
                // Check the type of bounding volume for the obstacle
                if (obstacleData.bbox instanceof THREE.Box3) {
                    if (playerBoundingSphere.intersectsBox(obstacleData.bbox)) {
                        return true; // Collision detected with a Box3
                    }
                } else if (obstacleData.bbox instanceof THREE.Sphere) {
                    if (playerBoundingSphere.intersectsSphere(obstacleData.bbox)) {
                        return true; // Collision detected with a Sphere
                    }
                }
            }
            return false; // No collision
        }

        // Function to update render distance based on slider
        function updateRenderDistance() {
            renderDistanceSetting = parseInt(renderDistanceSlider.value);
            // 1 unit in game = 1 meter (since FOREST_SIZE 500 means 500 units from center)
            // So, 1 setting = 100 meters, 10 setting = 1000 meters
            actualRenderDistance = renderDistanceSetting * 100;
            renderDistanceValueDisplay.textContent = `${actualRenderDistance} meters`;

            // Update camera's far clipping plane
            camera.far = actualRenderDistance + 100; // Add a buffer
            camera.updateProjectionMatrix();

            // Re-evaluate visibility of all obstacles based on new render distance
            // This is crucial when the setting changes, or on game start/reset
            obstacles.forEach(obstacle => {
                const distance = player.position.distanceTo(obstacle.object.position);
                obstacle.object.visible = distance < actualRenderDistance;
            });
        }


        // Animation loop
        function animate() {
            if (isPaused) {
                // If paused, do not update game logic, just render current state
                renderer.render(scene, camera);
                return;
            }

            // Store the animation frame ID
            animationFrameId = requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000; // Time in seconds since last frame

            // Update score
            score += SCORE_PER_SECOND * delta;
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`; // Display integer score

            // Apply gravity
            if (player.position.y > PLAYER_HEIGHT || isJumping) {
                playerVerticalVelocity -= GRAVITY * delta;
            }
            player.position.y += playerVerticalVelocity * delta;

            // Prevent falling through the ground
            if (player.position.y < PLAYER_HEIGHT) {
                player.position.y = PLAYER_HEIGHT;
                playerVerticalVelocity = 0;
                isJumping = false; // Reset jumping state when on ground
            }

            // Check if player is actively moving (W,A,S,D pressed)
            const isPlayerActivelyMoving = moveForward || moveBackward || moveLeft || moveRight;

            // Update isCurrentlySprinting based on key state, movement, and stamina
            // Player is sprinting if sprint key is down, they are moving, and have *any* stamina
            isCurrentlySprinting = isSprintKeyDown && isPlayerActivelyMoving && playerStamina > 0;

            // Stamina logic
            if (isCurrentlySprinting) {
                // Drain stamina only if actually sprinting
                playerStamina = Math.max(0, playerStamina - staminaDrainRate * delta);
                // If stamina drops to 0 while sprinting, automatically stop sprinting
                if (playerStamina === 0) {
                    isCurrentlySprinting = false;
                }
            } else if (playerStamina < MAX_STAMINA) {
                // Regenerate stamina if not currently sprinting and not full
                playerStamina = Math.min(MAX_STAMINA, playerStamina + staminaRegenRate * delta);
            }

            // Determine current player speed based on stamina and sprinting state
            let currentSpeed;
            if (isCurrentlySprinting) {
                currentSpeed = SPRINT_SPEED_VALUE; // Sprinting speed
            } else if (playerStamina === 0) {
                currentSpeed = OUT_OF_STAMINA_PLAYER_SPEED; // Out of stamina speed
            } else {
                currentSpeed = NORMAL_PLAYER_SPEED; // Normal walking speed
            }

            // Apply crouch multiplier to the determined currentSpeed
            if (isCrouching) {
                currentSpeed *= CROUCH_SPEED_MULTIPLIER;
            }

            // Calculate potential player movement
            const currentPosition = player.position.clone();
            const potentialMove = new THREE.Vector3();

            if (moveForward) potentialMove.z -= currentSpeed * delta;
            if (moveBackward) potentialMove.z += currentSpeed * delta;
            if (moveLeft) potentialMove.x -= currentSpeed * delta;
            if (moveRight) potentialMove.x += currentSpeed * delta;

            // Apply movement relative to player's current rotation
            const rotatedMove = potentialMove.applyQuaternion(player.quaternion);

            const nextPosition = currentPosition.clone().add(rotatedMove);

            // Check for collisions before applying movement
            // Only check horizontal movement for collisions with trees/rocks
            const nextHorizontalPosition = new THREE.Vector3(nextPosition.x, player.position.y, nextPosition.z);

            if (!checkCollisions(nextHorizontalPosition)) {
                player.position.x = nextPosition.x;
                player.position.z = nextPosition.z;
            } else {
                // If collision, try to move only on one axis at a time to allow sliding
                const nextPositionX = new THREE.Vector3(nextPosition.x, player.position.y, currentPosition.z);
                const nextPositionZ = new THREE.Vector3(currentPosition.x, player.position.y, nextPosition.z);

                if (!checkCollisions(nextPositionX)) {
                    player.position.x = nextPositionX.x;
                }
                if (!checkCollisions(nextPositionZ)) {
                    player.position.z = nextPositionZ.z;
                }
            }

            // Clamp player position within forest boundaries
            player.position.x = Math.max(-FOREST_SIZE + 1, Math.min(FOREST_SIZE - 1, player.position.x));
            player.position.z = Math.max(-FOREST_SIZE + 1, Math.min(FOREST_SIZE - 1, player.position.z));
            // player.position.y is handled by jumping/crouching/gravity

            // Flickering light effect
            scene.children.forEach(obj => {
                if (obj instanceof THREE.PointLight && obj.userData.initialIntensity !== undefined) {
                    const flickerAmount = obj.userData.flickerAmount;
                    const flickerSpeed = obj.userData.flickerSpeed;
                    const minIntensity = obj.userData.minIntensity || 0; // Get min intensity or default to 0

                    // Use a sine wave combined with random noise for flickering
                    let newIntensity = obj.userData.initialIntensity * (1 + flickerAmount * Math.sin(time * flickerSpeed) + (Math.random() - 0.5) * 0.5);
                    // Ensure intensity stays above a minimum value and doesn't exceed initial
                    obj.intensity = Math.max(minIntensity, Math.min(obj.userData.initialIntensity, newIntensity));
                }
            });

            // Update object visibility based on player position and render distance
            obstacles.forEach(obstacle => {
                const distance = player.position.distanceTo(obstacle.object.position);
                obstacle.object.visible = distance < actualRenderDistance;
            });


            // Ghost following logic
            if (ghost && player) {
                const direction = new THREE.Vector3();
                // Get the direction from the ghost to the player
                direction.subVectors(player.position, ghost.position).normalize();

                // Move ghost towards the player
                ghost.position.addScaledVector(direction, GHOST_SPEED * delta);

                // Make the ghost look at the player
                ghost.lookAt(player.position);

                // Check for collision between ghost and player
                const distanceBetweenGhostAndPlayer = ghost.position.distanceTo(player.position);
                const combinedCollisionRadius = PLAYER_COLLISION_RADIUS + GHOST_COLLISION_RADIUS;
                if (distanceBetweenGhostAndPlayer < combinedCollisionRadius) {
                    gameOver(); // Trigger game over if collision occurs
                }
            }

            prevTime = time; // Update previous time for next frame

            // Update stamina bar UI
            if (staminaBarFill) {
                const staminaPercentage = (playerStamina / MAX_STAMINA) * 100;
                staminaBarFill.style.width = `${staminaPercentage}%`;
                // Change color based on stamina level
                if (playerStamina < MAX_STAMINA * 0.25) {
                    staminaBarFill.style.backgroundColor = '#ff0000'; // Red when low
                } else if (playerStamina < MAX_STAMINA * 0.5) {
                    staminaBarFill.style.backgroundColor = '#ffff00'; // Yellow when medium
                } else {
                    staminaBarFill.style.backgroundColor = '#00ff00'; // Green when high
                }
            }

            renderer.render(scene, camera); // Render the scene
        }

        // Start the game when the window loads
        window.onload = function () {
            init();
            // The animate loop is started inside init, but isPaused is true, so it will render only.
            // It will fully start updating game logic when the "Start Game" button is clicked.
        };
    </script>
</body>
</html>
